##############################################################################
#	        Words Game
##############################################################################

Cr√©er dossier projet "vite-chat-app"

lien tuto:
https://dev.to/novu/building-a-chat-app-with-socketio-and-react-2edj


#=====================================	
#	Cr√©ation Front End Vite ReactJS
#=====================================

Se placer dans le dossier o√π l'on veut cr√©er le projet et lancer la commande:
	Se placer dans le dossier o√π l'on veut cr√©er le projet (ici vite-chat-app) et lancer la commande:
	npm create vite@latest
	=> y
	=> Nom du projet: ex: "client"
	=> React
	=> Javascript

Ouvrir vite-chat-app dans vscode:
	code .
	
Une fois termin√© se placer dans "client" et lancer l'installation des d√©pendances:
	cd client
	npm i
	
Une fois termin√© lancer l'installation des d√©pendances:
	npm install socket.io-client react-router-dom
	
Tester que l'application marche:
	npm run dev	

Supprimer tout d App.js et mettre:
    <div>
      <p>Hello World !</p>
    </div>

On note le port sur lequel ViteJS lance le mode dev:
	=> 5173
	=> Cela nous servira pour dire au serveur de cr√©er une socket qui √©coute sur ce port
	
--------------------------		
	Variables Envvironnement
--------------------------	

cr√©er fichier ".env" pour y mettre:
	VITE_SERVER_URL=localhost
	VITE_SERVER_PORT=5000
	
#=====================================	
#	Cr√©ation Back End Express
#=====================================
Cr√©er dossier "server" sous projet "vite-chat-app"

--------------------------		
	Installation packet
--------------------------
ouvrir nouveau terminal dans vscode
	cd server
	npm init -y
	npm i express nodemon cors dotenv socket.io 
	
--------------------------		
	Package.json
--------------------------	
dans package.json mettre server.js sur variable main:
	"main": "server.js",
	
puis mettre les script de d√©marrage:	
	"scripts": {
	"start": "node -r dotenv/config server.js",
	"dev": "nodemon -r dotenv/config server.js"
	},

--------------------------		
	Variables Envvironnement
--------------------------	

cr√©er fichier ".env" pour y mettre:
	SERVER_PORT=5000
	# PREFIX=

	# For listening socket from front
	FRONT_URL=127.0.0.1
	FRONT_PORT=5173
	
--------------------------		
	Fichier app.js
--------------------------
cr√©er sous racine du dossier server:
	app.js


mettre le contenu suivant:
	/*** IMPORT */
	const express = require('express')
	const cors = require('cors')

	/*** INIT API */
	const app = express()

	const PREFIX = process.env.PREFIX || ""

	app.use(cors({
		origin: "*",
		methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
		allowedHeaders: "Origin, X-Requested-With, x-access-token, role, Content, Accept, Content-Type, Authorization"
	}))

	app.use(express.json())
	app.use(express.urlencoded({ extended: true }))


	// /*** IMPORT ROUTER */
	// const user_router = require('./routes/user_r')

	/*** MAIN ROUTER */
	app.get(PREFIX + '/', (req, res) => res.send(`I'm online. All is OK ! `))
	// app.use(PREFIX + '/users', user_router)
	app.all('*', (req, res) => res.status(501).send('What the hell are you doing !?!'))

	/*** Export for server and Test */
	module.exports = app

	
--------------------------		
	Fichier server.js
--------------------------
cr√©er sous racine du dossier server:
	server.js


mettre le contenu suivant:
	/*************************/
	/*** Import used modules */
	const app = require('./app')
	
	const SERVER_PORT = process.env.SERVER_PORT || 4000

	/*** START Server */
	app.listen(SERVER_PORT, () => {
		console.log(`This server running on port ${SERVER_PORT}`)
})



#=====================================	
#	Cr√©ation Socket
#=====================================
--------------------------		
	Socket cot√© Server
--------------------------
Cr√©er un fichier "socket.js" et y mettre le contenu suivant:
	const app = require('./app')
	const http = require('http').Server(app);

	const FRONT_URL = process.env.FRONT_URL || "localhost"
	const FRONT_PORT = process.env.FRONT_PORT || 3000
	const SOCKET_URL_LISTEN = "http://" + FRONT_URL + ":" + FRONT_PORT //"http://localhost:3000"

	const socketIO = require('socket.io')(http, {
		cors: {
			origin: SOCKET_URL_LISTEN
		}
	});

	socketIO.on('connection', (socket) => {
		console.log(`‚úÖ: ${socket.id} user just connected!`);

		socketIO.emit('NewUser', socket.id);

		socket.on('disconnect', () => {
			console.log('‚ùå: A user disconnected');
		});
	});

	module.exports = http
	
	
Modifier le fichier "server.js" pour qu'il prenne la socket comme ceci:

	/*************************/
	/*** Import used modules */
	const http = require('./socket')

	const SERVER_PORT = process.env.SERVER_PORT || 4000

	http.listen(SERVER_PORT, () => {
		console.log(`Server listening on ${SERVER_PORT}`);
	});


--------------------------		
	Socket cot√© Client
--------------------------
Dans fichier "App.js" du client ajouter le code suivant en t√™te du fichier pour g√©rer la socket: 
	import socketIO from 'socket.io-client';

	// Socket listenning server
	const SERVER_URL = import.meta.env.VITE_SERVER_URL || "localhost"
	const SERVER_PORT = import.meta.env.VITE_SERVER_PORT || 4000
	const socket = socketIO.connect("http://" + SERVER_URL + ":" + SERVER_PORT);

=> l'url doit correspondre √† celle de notre serveur api sur lequel le listen est lanc√© dans "server.js"
	
	

#=====================================	
#	Home Page
#=====================================

Dans dossier "client" cr√©er la page "Home.jsx" dans un dossier "pages" de pr√©f√©rence:
Y mettre le contenu suivant: 
	import React, { useState } from 'react';
	import { useNavigate } from 'react-router-dom';

	const Home = () => {
	  const navigate = useNavigate();
	  const [userName, setUserName] = useState('');

	  const handleSubmit = (e) => {
		e.preventDefault();
		localStorage.setItem('userName', userName);
		navigate('/chat');
	  };
	  return (
		<form className="home__container" onSubmit={handleSubmit}>
		  <h2 className="home__header">Sign in to Open Chat</h2>
		  <label htmlFor="username">Username</label>
		  <input
			type="text"
			minLength={6}
			name="username"
			id="username"
			className="username__input"
			value={userName}
			onChange={(e) => setUserName(e.target.value)}
		  />
		  <button className="home__cta">SIGN IN</button>
		</form>
	  );
	};

	export default Home;


#=====================================	
#	Chat Page
#=====================================
--------------------------		
	Component ChatBar
--------------------------
Cr√©er dans src/components/ le  fichier "ChatBar.jsx" et y mettre ce contenu:
	import React from 'react';

	const ChatBar = () => {
	  return (
		<div className="chat__sidebar">
		  <h2>Open Chat</h2>

		  <div>
			<h4 className="chat__header">ACTIVE USERS</h4>
			<div className="chat__users">
			  <p>User 1</p>
			  <p>User 2</p>
			  <p>User 3</p>
			  <p>User 4</p>
			</div>
		  </div>
		</div>
	  );
	};

	export default ChatBar;

--------------------------		
	Component ChatBody
--------------------------
Cr√©er dans src/components/ le  fichier "ChatBody.jsx" et y mettre ce contenu:
	import React from 'react';
	import { useNavigate } from 'react-router-dom';

	const ChatBody = () => {
		const navigate = useNavigate();

		const handleLeaveChat = () => {
			localStorage.removeItem('userName');
			navigate('/');
			window.location.reload();
		};

		return (
			<>
				<header className="chat__mainHeader">
					<p>Hangout with Colleagues</p>
					<button className="leaveChat__btn" onClick={handleLeaveChat}>
						LEAVE CHAT
					</button>
				</header>

				{/*This shows messages sent from you*/}
				<div className="message__container">
					<div className="message__chats">
						<p className="sender__name">You</p>
						<div className="message__sender">
							<p>Hello there</p>
						</div>
					</div>

					{/*This shows messages received by you*/}
					<div className="message__chats">
						<p>Other</p>
						<div className="message__recipient">
							<p>Hey, I'm good, you?</p>
						</div>
					</div>

					{/*This is triggered when a user is typing*/}
					<div className="message__status">
						<p>Someone is typing...</p>
					</div>
				</div>
			</>
		);
	};

	export default ChatBody;

--------------------------		
	Component ChatFooter
--------------------------
Cr√©er dans src/components/ le  fichier "ChatFooter.jsx" et y mettre ce contenu:
	import React, { useState } from 'react';

	const ChatFooter = ({ socket }) => {
	  const [message, setMessage] = useState('');

	  const handleSendMessage = (e) => {
		e.preventDefault();
		console.log({ userName: localStorage.getItem('userName'), message });
		setMessage('');
	  };
	  return (
		<div className="chat__footer">
		  <form className="form" onSubmit={handleSendMessage}>
			<input
			  type="text"
			  placeholder="Write message"
			  className="message"
			  value={message}
			  onChange={(e) => setMessage(e.target.value)}
			/>
			<button className="sendBtn">SEND</button>
		  </form>
		</div>
	  );
	};

	export default ChatFooter;

--------------------------		
	Chat Page
--------------------------
Dans dossier "client" cr√©er la page "Home.jsx" dans un dossier "pages" de pr√©f√©rence:
Y mettre le contenu suivant:
	import React from 'react';
	import ChatBar from '../components/ChatBar';
	import ChatBody from '../components/ChatBody';
	import ChatFooter from '../components/ChatFooter';


	const ChatPage = ({ socket }) => {
		return (
			<div className="chat">
				<ChatBar />
				<div className="chat__main">
					<ChatBody />
					<ChatFooter socket={socket} />
				</div>
			</div>
		);
	};

	export default ChatPage;


#=====================================	
#	Routage Page Client
#=====================================
Dans fichier "App.js":
mettre le contenu suivant dans le return:
    <BrowserRouter>
      <div>
        <Routes>
          <Route path="/" element={<Home socket={socket} />}></Route>
          <Route path="/chat" element={<ChatPage socket={socket} />}></Route>
        </Routes>
      </div>
    </BrowserRouter>




#=====================================	
#	Sending messages between Client and Server
#=====================================
--------------------------		
	Client
--------------------------
Dans le fichier "ChatFooter.jsx" ajouter dans la fonction handleSendMessage juste avant setMessage(''); :
	if (message.trim() && localStorage.getItem('userName')) {
		const date = new Date()
		const name = localStorage.getItem('userName')
		socket.emit('message', {
			text: message,
			name: name,
			id: `${name}_${date.toISOString()}`,
			date: date,
			socketID: socket.id,
		});
	}

--------------------------		
	Server
--------------------------
Dans le fichier "socket.js" ajouter la fonction pour √©couter sur la socket le terme "message" en ajoutant cette fonction juste avant socket.on('disconnect', () => { :

    //Listens and sends the return message to all the users on the server
    socket.on('message', (data) => {
        socketIO.emit('messageResponse', data);
    });


--------------------------		
	Client Ecouter messageResponse du serveur 
--------------------------
Il faut ecouter le terme "messageResponse" venant du server et compiler les messages dans un Array messages qu'on passe √† l'√©l√©ment chat body.

Voici √† quoi doit ressembler le fichier "ChatPage.js" :
	import React, { useEffect, useState } from 'react';
	import ChatBar from '../components/ChatBar';
	import ChatBody from '../components/ChatBody';
	import ChatFooter from '../components/ChatFooter';


	const ChatPage = ({ socket }) => {
		const [messages, setMessages] = useState([]);

		useEffect(() => {
			socket.on('messageResponse', (data) => setMessages([...messages, data]));
		}, [socket, messages]);

		return (
			<div className="chat">
				<ChatBar socket={socket} />
				<div className="chat__main">
					<ChatBody messages={messages} />
					<ChatFooter socket={socket} />
				</div>
			</div>
		);
	};

	export default ChatPage;

--------------------------		
	Client Mettre √† jour liste des Messages pour tous les clients
--------------------------
Mettre √† jour le fichier "ChatBody.jsx" pour qu'il puisse compiler tous les messages dans le message_container

Voici √† quoi doit ressembler le fichier "ChatPage.js" :
	import React from 'react';
	import { useNavigate } from 'react-router-dom';

	const ChatBody = ({ messages }) => {
		const navigate = useNavigate();

		const handleLeaveChat = () => {
			localStorage.removeItem('userName');
			navigate('/');
			window.location.reload();
		};

		return (
			<>
				<header className="chat__mainHeader">
					<p>Hangout with Colleagues</p>
					<button className="leaveChat__btn" onClick={handleLeaveChat}>
						LEAVE CHAT
					</button>
				</header>

				<div className="message__container">
					{messages.map((message) =>
						message.name === localStorage.getItem('userName') ? (
							<div className="message__chats" key={message.id}>
								<p className="sender__name">You</p>
								<div className="message__sender">
									<p>{message.text}</p>
								</div>
							</div>
						) : (
							<div className="message__chats" key={message.id}>
								<p>{message.name}</p>
								<div className="message__recipient">
									<p>{message.text}</p>
								</div>
							</div>
						)
					)}

					<div className="message__status">
						<p>Someone is typing...</p>
					</div>
				</div>
			</>
		);
	};

	export default ChatBody;


#=====================================	
#	Afficher tous les joueurs connect√©s
#=====================================

On veut voir tous les joueurs sur le chat dans la chatbar. 
On va donc regarder les utilisateurs qui se loguent et les envoyer au serveurs pour qu'il renvoie √† tous les clients la listes compl√®te des users.

--------------------------		
	Client Send newUser to Server
--------------------------
Dans "Home.jsx" ajouter la fonction suivante dans la fonction handleSubmit() 
    //sends the username and socket ID to the Node.js server
    socket.emit('newUser', { userName, socketID: socket.id });

=> Ne pas oublier d'ajouter la props { socket }, envoy√© par App.jsx, en input de la const Home

--------------------------		
	Server Listen newUser and send to List of Users in newUserResponse
--------------------------
Dans fichier "socket.js" initialiser en haut un array users et 
	let users = [];

Toujours dans le fichier "socket.js" ajouter la fonction listen "newUser"  apr√®s listen "message":
    //Listens when a new user joins the server
    socket.on('newUser', (data) => {
        //Adds the new user to the list of users
        users.push(data);
        //Sends the list of users to the client
        socketIO.emit('newUserResponse', users);
    });

Toujours dans le fichier "socket.js" supprimer le user de l'Array users dans la fonction listen "disconnect" :
	//Updates the list of users when a user disconnects from the server
	users = users.filter((user) => user.socketID !== socket.id);
	// console.log(users);
	//Sends the list of users to the client
	socketIO.emit('newUserResponse', users);
	socket.disconnect();

--------------------------		
	Client Listen newUserResponse to update list users
--------------------------
Dans le fichier "ChatBar.jsx" :
=> Ajouter props { socket } en input de ChatBar

=> Avant return ajouter gestion users comme ceci:
    const [users, setUsers] = useState([]);

    useEffect(() => {
        socket.on('newUserResponse', (data) => setUsers(data));
    }, [socket, users]);
	
=> Remplacer div className="chat__users" avec ceci:
	<div className="chat__users">
		{users.map((user) => (
			<p key={user.socketID}>{user.userName}</p>
		))}
	</div>




#=====================================	
#	Client AutoScroll
#=====================================

Auto-scroll and Notify users when a user is typing

--------------------------		
	Client 
--------------------------

Dans le fichier "ChatPage.jsx":

=> Ajouter un useRef qui servira √† taguer une fausse div √† la fin du message__container du chat body:
	const lastMessageRef = useRef(null);
	
=> Ajouter use effect pour scroller d√®s que le state message change:
  useEffect(() => {
    // üëáÔ∏è scroll to bottom every time messages change
    lastMessageRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

=> faire passer en props le useRef √† ChatBody qui servira √† taguer une fausse div en fin du message__container:
	<ChatBody messages={messages} lastMessageRef={lastMessageRef} />
	
Dans le fichier "ChatBody.jsx":	
=> Ajouter props { lastMessageRef } en input de ChatBody	

=> Ajouter √† la fin du message__container du ChatBody:	
	<div ref={lastMessageRef} />
	


#=====================================	
#	Client Affichage quand quelqu'un √©crit
#=====================================	
	
--------------------------		
	Client 
--------------------------	
Dans le fichier "ChatPage.jsx":	
=> Ajouter un useSate pour le typingStatus:
	const [typingStatus, setTypingStatus] = useState('');	

=> Ajouter use effect pour mettre √† jour le typingStatus quand il y a une typingResponse venant du server :
    useEffect(() => {
        socket.on('typingResponse', (data) => setTypingStatus(data));
    }, [socket]);
	
=> faire passer en props le typingStatus √† ChatBody qui servira √† dire qu'un utilisateur est entrain d'√©crire:	
	<ChatBody messages={messages} typingStatus={typingStatus} lastMessageRef={lastMessageRef} />

Dans le fichier "ChatBody.jsx":	
=> Ajouter props { typingStatus } en input de ChatBody

=> Remplacer la div message__status par :
	<div className="message__status">
		<p>{typingStatus}</p>
	</div>	

Dans le fichier "ChatFooter.jsx":
=> Ajouter la fonction "handleTyping" qui envera au server que le user du client est en train de taper		
    const handleTyping = () => {
        socket.emit('typing', `${localStorage.getItem('userName')} is typing`);
    };

=> Dans la balise input ajouter la propri√©te "onKeyDown" qui regarde quand quelqu'un tape :
	onKeyDown={handleTyping}

		
--------------------------		
	Server 
--------------------------
Le serveur doit √©couter que quelqu'un tape et envoyer l'information √† tous le monde sauf le user qui √©crit

Dans le fichier "socket.js" ajouter la fonction listen "typing"  apr√®s listen "message":
    //Listens when a user is typing
    socket.on('typing', (data) => {
        socket.broadcast.emit('typingResponse', data)
    });


#=====================================	
#	UserCard avec healthbar
#=====================================

--------------------------		
	Component UserCard
--------------------------
Cr√©er dans src/components/ le  fichier "UserCard.jsx" et y mettre ce contenu:
	import React, { useEffect, useState } from 'react';

	const UserCard = ({ socketID, username, users }) => {
		const [progress, setProgress] = useState(100);
		const total_points = 100

		const getColor = () => {
			if (progress < 40) {
				return "#ff0000"
			} else if (progress < 70) {
				return "#ffa500"
			} else {
				return "#2ecc71"
			}
		}

		useEffect(() => {
			const user = users.filter((user) => user.socketID === socketID)[0];
			setProgress(user.score / total_points * 100)
		}, [users, socketID, username]);

		return (
			<div className="chat__usercard">
				<p >{username}</p>
				<div className="chat__healthbar">
					<div className="progress-bar">
						<div className='progress-bar-fill' style={{ width: `${progress}%`, backgroundColor: getColor() }}></div>
					</div>
					<div className='progress-label'>{progress}%</div>

				</div>
			</div>

		);
	};

	export default UserCard;

--------------------------		
	Component ChatBar
--------------------------
Dans le fichier "ChatBar.jsx" changer le return pour prendre le component UserCard.jsx comme ceci
Cr√©er dans src/components/ le  fichier "ChatBar.jsx" et y mettre ce contenu:

		return (
			<div className="chat__sidebar">
				<h1>Words Game</h1>

				<div>
					<h4 className="chat__header">ACTIVE USERS</h4>
					<ul className="chat__users">
						{users.map((user) => (
							<UserCard key={user.socketID} socketID={user.socketID} username={user.userName} users={users} />
						))}
					</ul>
				</div>
			</div>
		);




#=====================================	
#	Cr√©ation Database MariaDB pour l'API
#=====================================

--------------------------		
	.env
--------------------------
Cr√©er fichier ".env" √† la racine du projet avec :
	# BDD
	MARIADB_HOST=127.0.0.1
	MARIADB_PORT=3306
	MARIADB_DATABASE=db_words_game
	MARIADB_ROOT_PASSWORD=toor
	MARIADB_USER=roger
	MARIADB_PASSWORD=regor
	MARIADB_SYNCHRONIZE=true
	
--------------------------		
	Docker compose
--------------------------
cr√©er fichier "docker-compose.yml" √† la racine du projet et y mettre
-------------------------------------------------------
	version: '3.1'

	services:

	  bdd:
		container_name: local_bdd
		image: mariadb:latest
		env_file:
		  - .env
		restart: always
		volumes:
		  - ./mysql:/var/lib/mysql

		ports:
		  - 3306:3306

	  adminer:
		container_name: adminer
		image: adminer
		restart: always
		ports:
		  - 8080:8080
-------------------------------------------------------


--------------------------		
	Lancer Docker Compose
--------------------------
	docker compose up -d

--------------------------		
	Aller sur Adminer
--------------------------
http://localhost:8080/

entrer les √©lements de connexion mis dans le "docker-compose.yml"
      Server: bdd
	  Utilisateur: roger
	  Mot de passe: regor
      Base de donn√©e: db_words_game
	  

--------------------------		
	Script lancement DB
--------------------------
On peut ajouter un script dans le fichier "package.json" pour red√©marrer automatiquement la database:
    "db:dev:rm": "docker compose rm -s -f -v",
    "db:dev:up": "docker compose up -d",
    "db:dev:restart": "npm run db:dev:rm && npm run db:dev:up",
	
On peut aussi pr√©ciser le service que l'on veut d√©marrer (ou arr√©ter) en mettant le nom du service, ici "bdd", juste apr√®s le terme "docker compose"


--------------------------		
	Configuration Sequelize
--------------------------
Installer sequelize:
	npm i sequelize mysql2
	
cr√©er un fichier "db.config.js" et y mettre le contenu suivant:
	/*************************/
	/*** Import used modules */
	const { Sequelize } = require('sequelize')

	/*************************/
	/*** R√©cup√©ration variables de connexion */
	const MARIADB_DATABASE = process.env.MARIADB_DATABASE
	const MARIADB_USER = process.env.MARIADB_USER
	const MARIADB_PASSWORD = process.env.MARIADB_PASSWORD
	const MARIADB_HOST = process.env.MARIADB_HOST
	const MARIADB_PORT = process.env.MARIADB_PORT

	/*************************/
	/*** Connexion √† la base de donn√©e */
	let sequelize = new Sequelize(
		MARIADB_DATABASE,
		MARIADB_USER,
		MARIADB_PASSWORD,
		{
			host: MARIADB_HOST,
			port: MARIADB_PORT,
			dialect: 'mysql',
			logging: false
		}
	)

	/*************************/
	/*** Appel des mod√®les */
	const db = {}
	db.sequelize = sequelize


	/*************************/
	/*** Mise en place des relations */


	/*************************/
	/*** Synchronisation des mod√®les */
	db.sequelize.sync({ alter: true })     // permet de synchroniser les models JS avec les tables dans la BDD

	module.exports = db



/!\ La synchronisation des mod√®les est √† commenter une fois que l'application est stable. Elle peut engendrer de gros probl√®me en cas d'erreur de code en mode de d√©ploiement

	
--------------------------		
	Condition D√©marrage BDD avant listen API
--------------------------	
dans server.js ajouter import de la db config:
	let DB = require('./db.config')
	
et refaire le d√©marage de l'API conditionner par le DB.authenticate:
	/****************************/
	/*** D√©marrage de l'API*/
	DB.sequelize.authenticate()
		.then(() => console.log('MariaDB Connexion OK'))
		.then(() => {
			app.listen(process.env.API_PORT, () => {
				console.log(`This server is running on port ${process.env.API_PORT}. Have fun !`)
			})
		})
		.catch(e => console.log('Database Error', e))

On peut faire le test en red√©marrant le server si on l'avait arr√©ter:
	npm run dev
	=> si message "MariaDB Connexion OK" et "This server is running on port ..."  => Tout est OK, on est connect√© √† MariaDB
	
	
#=====================================	
#	Cr√©ation Models MariaDB
#=====================================
Cr√©er dossier "models" √† la racine du projet:

cr√©er dedans ce dossier "models" nos fichiers model pour entit√©s: eleve, formateur, formation, module, note
 
exemple pour "User.js":
	/*************************/
	/*** Import used modules */
	const { DataTypes } = require('sequelize')

	/*************************/
	/*** Import used modules */
	module.exports = (sequelize) => {
		const User = sequelize.define('User', {
			id: {
				type: DataTypes.INTEGER(10),
				primaryKey: true,
				autoIncrement: true
			},
			firstname: {
				type: DataTypes.STRING(100),
				defaultValue: '',
				allowNull: false
			},
			lastname: {
				type: DataTypes.STRING(100),
				defaultValue: '',
				allowNull: false
			},
			email: {
				type: DataTypes.STRING,
				validate: {
					isEmail: true,             // Ici une contrainte de donn√©es
				},
				allowNull: false
			},
			password: {
				type: DataTypes.STRING(64),
				is: /^[0-9a-f]{64}$/i,        // Ici une contrainte de donn√©es
				allowNull: false
			},
		})
		return User
	}


#=====================================	
#	Appel des Models dans Config Mariadb
#=====================================
Dans notre fichier "db.config.js" ajouter sous "appel des mod√®les":
	db.User = require('./models/User')(sequelize)

#=====================================	
#	Controller User
#=====================================
Cr√©er dossier "controllers" √† la racine du projet:	

cr√©er dedans ce dossier "controllers" le fichier "User.js" et y mettre le contenu:
	/***********************************/
	/*** Import des module n√©cessaires */
	const DB = require('../db.config')
	const User = DB.User

	/**********************************/
	/*** Routage de la ressource User */

	exports.getAllUsers = (req, res) => {
		User.findAll()
			.then(users => res.json({ data: users }))
			.catch(err => res.status(500).json({ message: 'Database Error', error: err }))
	}

	exports.getUser = async (req, res) => {
		let pid = parseInt(req.params.id)

		try {
			// R√©cup√©ration de l'utilisateur et v√©rification
			let user = await User.findOne({ where: { id: pid } })
			if (user === null) {
				return res.status(404).json({ message: 'This user does not exist !' })
			}

			return res.json({ data: user })
		} catch (err) {
			return res.status(500).json({ message: 'Database Error', error: err })
		}
	}

	exports.addUser = async (req, res) => {
		const { firstname, lastname, email, password } = req.body

		// Validation des donn√©es re√ßues
		if (!firstname || !lastname || !email || !password) {
			return res.status(400).json({ message: 'Missing Data' })
		}

		try {
			// V√©rification si l'utilisateur existe d√©j√†
			const user = await User.findOne({ where: { email: email }, raw: true })
			if (user !== null) {
				return res.status(409).json({ message: `This email is already associated with a user !` })
			}

			// Hashage du mot de passe utilisateur
			//let hash = await bcrypt.hash(password, parseInt(process.env.BCRYPT_SALT_ROUND))
			//req.body.password = hash

			// C√©ation de l'utilisateur
			let userc = await User.create(req.body)
			return res.status(201).json({ message: 'User Created', data: userc })

		} catch (err) {
			if (err.name == 'SequelizeDatabaseError') {
				res.status(500).json({ message: 'Database Error', error: err })
			}
			res.status(500).json({ message: 'Hash Process Error', error: err })
		}
	}

	exports.updateUser = async (req, res) => {
		let pid = parseInt(req.params.id)
		const { firstname, lastname, email, password } = req.body

		try {
			// Recherche de l'utilisateur et v√©rification
			let user = await User.findOne({ where: { id: pid }, raw: true })
			if (user === null) {
				return res.status(404).json({ message: 'This user does not exist !' })
			}

			// r√©cup√©ration des donn√©es
			let userp = {}
			if (firstname) { userp.firstname = firstname }
			if (lastname) { userp.lastname = lastname }
			if (email) { userp.email = email }
			if (password) {
				// Password Hash
				// let hash = await bcrypt.hash(password, parseInt("process.env.BCRYPT_SALT_ROUND"))
				// userp.password = hash
				userp.password = password
			}

			// Mise √† jour de l'utilisateur
			await User.update(userp, { where: { id: pid } })
			return res.json({ message: 'User Updated', data: { ...user, ...userp } })
		} catch (err) {
			return res.status(500).json({ message: 'Database Error', error: err })
		}
	}

	exports.deleteUser = async (req, res) => {
		let pid = parseInt(req.params.id)

		// V√©rification si le champ id est pr√©sent et coh√©rent
		if (!pid) {
			return res.status(400).json({ message: `Missing Parameter` })
		}

		try {
			// Suppression
			let count = await User.destroy({ where: { id: pid } })
			// Test si r√©sultat
			if (count === 0) {
				return res.status(404).json({ message: `This user does not exist !` })
			}
			// Message confirmation Deletion
			return res.status(200).json({ message: `User (id: ${pid} ) Successfully Deleted. ${count} row(s) deleted` })

		} catch (err) {
			return res.status(500).json({ message: `Database Error`, error: err })
		}
	}

#=====================================	
#	Routes sp√©cifique √† nos entit√©s
#=====================================	
Cr√©er dossier "routes" √† la racine du projet:

cr√©er dedans ce dossier "routes" le fichier "User.js" et y mettre le contenu:
	/***********************************/
	/*** Import des module n√©cessaires */
	const express = require('express')
	const userCtrl = require('../controllers/User')

	/***************************************/
	/*** R√©cup√©ration du routeur d'express */
	let router = express.Router()

	/*********************************************/
	/*** Middleware pour logger dates de requete */
	router.use((req, res, next) => {
		const event = new Date()
		console.log('User Time:', event.toString())
		next()
	})


	/**********************************/
	/*** Routage de la ressource User */

	router.get('/', userCtrl.getAllUsers)

	router.get('/:id([0-9]+)', userCtrl.getUser)

	router.put('', userCtrl.addUser)

	router.patch('/:id([0-9]+)', userCtrl.updateUser)

	router.delete('/:id([0-9]+)', userCtrl.deleteUser)

	module.exports = router



#=====================================	
#	Routage principal
#=====================================	
dans fichier "app.js" ajouter:

sous "import router" ajouter l'import du router user.js:
	const user_router = require('./routes/User')
	
sous "main router" ajouter la route principal vers notre router user.js (entre app.get("/") et app.all("*"):
	app.use(PREFIX + '/users', user_router)


##############################################################################
#	       S√©curit√©
##############################################################################
#=====================================	
#	Chiffrement Mot de Passe
#=====================================

--------------------------		
	Config Bcrypt
--------------------------
Installation d√©pendance bcrypt:
	npm i bcrypt

Param√®tre de salage Bcrypt dans ".env":
	BCRYPT_SALT_ROUND=10

--------------------------		
	Update Controllers User.js
--------------------------
ajouter import bcrypt:
	const bcrypt = require('bcrypt')
	
dans fonction addUser() ajouter le hachage du mot de passe avant User.create(req.body) comme ceci:
	// Hashage du mot de passe utilisateur
	let hash = await bcrypt.hash(password, parseInt(process.env.BCRYPT_SALT_ROUND))
	req.body.password = hash

idem pour fonction updateUser():
	if (password) {
		// Password Hash
		let hash = await bcrypt.hash(password, parseInt("process.env.BCRYPT_SALT_ROUND"))
		userp.password = hash
	}


#=====================================	
#	Authentification
#=====================================	

--------------------------		
	Config JsonWebToken
--------------------------
Installation d√©pendance bcrypt:
	npm i jsonwebtoken

Param√®tre de salage Bcrypt dans ".env":
	JWT_SECRET=laphrasesuperlonguequiestsuperdifficileatrouver
	JWT_DURING=1h

--------------------------		
	MiddleWare jwtCheck.js
--------------------------	
Cr√©er dossier "middlewares" et cr√©er dedans le fichier "jwtCheck.js" avec ce contenu: 
	/***********************************/
	/*** Import des module n√©cessaires */
	const jwt = require('jsonwebtoken')

	/*************************/
	/*** Extraction du token */
	const extractBearer = authorization => {
		if(typeof authorization !== 'string'){
			return false
		}

		// On isole le token
		const matches = authorization.match(/(bearer)\s+(\S+)/i)

		return matches && matches[2]
	}

	/******************************************/
	/*** V√©rification de la pr√©sence du token */
	const checkTokenMiddleware = (req, res, next) => {
		const token = req.headers.authorization && extractBearer(req.headers.authorization)

		if(!token){
			return res.status(401).json({ message: 'Ho le petit malin !!!'})
		}

		// V√©rifier la validit√© du token
		jwt.verify(token, process.env.JWT_SECRET, (err, decodedToken) => {
			if(err){
				return res.status(401).json({message: 'Bad token'})
			}
			next()
		})
	}

	module.exports = checkTokenMiddleware
	
--------------------------		
	Controller d'Authentification
--------------------------	
Dans dossier "controllers" cr√©er fichier "Auth.js" avec ce contenu:
	/*************************/
	/*** Import used modules */
	const bcrypt = require('bcrypt')
	const jwt = require('jsonwebtoken')

	const DB = require("../db.config")
	const User = DB.User

	/**********************************/
	/*** Unit route for Auth resource */

	exports.login = async (req, res) => {
		const { email, password } = req.body
		// Check data from request
		if (!email || !password) {
			return res.status(400).json({ message: 'Bad credentials' })
		}

		try {
			// Get admin
			let user = await User.findOne({ where: { email: email } })
			// Test si r√©sultat
			if (user === null) {
				return res.status(404).json({ message: `This user does not exist !` })
			}
			// Password check  
			let test = await bcrypt.compare(password, user.password)
			if (!test) {
				return res.status(401).json({ message: 'Wrong password' })
			}

			// JWT generation
			const token = jwt.sign({
				payload: { userId: user.id, group: "user" }
			}, process.env.JWT_SECRET, { expiresIn: process.env.JWT_DURING })

			return res.json({ access_token: token })
		} catch (err) {
			console.log(err)
		}
	}


--------------------------		
	Routes sp√©cifique √† Authentification
--------------------------	
Dans dossier "routes" le fichier "Auth.js" et y mettre le contenu:
	/***********************************/
	/*** Import des module n√©cessaires */
	const express = require('express')
	const authCtrl = require('../controllers/Auth')
	const userCtrl = require('../controllers/User')

	/***************************************/
	/*** R√©cup√©ration du routeur d'express */
	let router = express.Router()

	/*********************************************/
	/*** Middleware pour logger dates de requete */


	/**********************************/
	/*** Routage de la ressource Auth */
	router.post('/signin', userCtrl.addUser)
	router.post('/login', authCtrl.login)

	module.exports = router

--------------------------		
	Routage principal
--------------------------
dans fichier "app.js" ajouter:

sous "import router" ajouter l'import du router Auth.js:
	const auth_router = require('./routes/Auth')
	
sous "main router" ajouter la route principal vers notre router Auth.js (entre app.get("/") et app.all("*"):
	app.use(PREFIX + '/', auth_router)


#=====================================	
#	Authorization Roles (Moindre Privil√®ge API)
#=====================================	

roles:
https://www.youtube.com/watch?v=cs-zr4-0qXU&list=PLwJWw4Pbl4w_sEL35LMX9PdWEea4Rq6JK&index=14

--------------------------		
	Variable environnement ROLES_LIST
--------------------------
Ajouter dans le .env la liste des roles dans un string format JSON comme ceci:
	# ROLES
	ROLES_LIST={"admin":5248,"modo":1295,"user":3284}



--------------------------		
	User Model Update
--------------------------
Dans fichier "models/User.js" ajouter la propri√©t√© roles comme ceci:
	roles: {
		type: DataTypes.JSON(),
		allowNull: false
	},


--------------------------		
	Controller User.js Update
--------------------------
Dans controllers/User.js ajouter l'import de la liste de roles en haut comme ceci:
	const ROLES_LIST = JSON.parse(process.env.ROLES_LIST)

Dans la fonction "addUser" ajouter la cr√©ation du role par d√©faut juste avant la cr√©ation du user dans la BDD comme ceci:
	// Ajout du role de base
	req.body.roles = { "roles": [ROLES_LIST.user] }

--------------------------		
	Controller Auth.js Update
--------------------------
Dans la fonction login, Ajouter le role de l'utilisateur dans le token g√©n√©r√© comme ceci:
	// JWT generation
	const token = jwt.sign({
		payload: { userId: user.id, roles: JSON.parse(user.roles).roles }
	}, process.env.JWT_SECRET, { expiresIn: process.env.JWT_DURING })
	

--------------------------		
	Middleware jwtCheck Update
--------------------------
Dans la fonction checkTokenMiddleware profit√© du d√©codage du token pour extraire le userId et le role et les ajouter √† la req comme ceci:
    // V√©rifier la validit√© du token
    jwt.verify(token, process.env.JWT_SECRET, (err, decodedToken) => {
        if (err) {
            return res.status(401).json({ message: 'Bad token' })
        }
        req.userID = decodedToken.payload.userId
        req.roles = decodedToken.payload.roles
        next()
    })

--------------------------		
	Cr√©ation Middleware roleCheck 
--------------------------		 
Dans le dossier "middlewares" cr√©er un fichier "roleCheck.js" avec le contenu suivant:
	const roleCheck = (...authRoles) => {
		return (req, res, next) => {

			if (!req?.roles) {
				return res.sendStatus(403)
			}

			const userRolesChecks = req.roles.map(role => authRoles.includes(role))
			const isAutorized = userRolesChecks.find(val => val === true)
			// console.log("ROLECHECK: user roles ", req.roles)
			// console.log("ROLECHECK: userRolesChecks ", userRolesChecks)
			// console.log("ROLECHECK: isAutorized ", isAutorized)

			if (!isAutorized) {
				return res.sendStatus(403)
			}

			next()
		}
	}
	module.exports = roleCheck


--------------------------		
	Blocage des Routes avec jwtCheck et roleCheck
--------------------------	
Pour l'exemple on veut bloquer le getUser √† toutes les personnes qui n'ont pas un des roles user, modo ou admin

Dans le fichier "routes/User.js":
Ajouter en haut les imports:
	const roleCheck = require("../middlewares/roleCheck")
	const jwtCheck = require("../middlewares/jwtCheck")
	const ROLES_LIST = JSON.parse(process.env.ROLES_LIST || '{ "admin": 1, "modo": 2, "user": 3 }')

Sur la route concern√©e ajouter les middleware avec les roles autoris√© pour cette action comme ceci:
	router.get('/', jwtCheck, roleCheck(ROLES_LIST.user, ROLES_LIST.modo, ROLES_LIST.admin), userCtrl.getAllUsers)






#=====================================	
#	Ajout roleCheck Owner
#=====================================
Pour autoriser un utilisateur √† modifier les donn√©es le concernant, on ajoute une option role "owner" dans le roleCheck
et on modifie un peu la fonction pour qu'il puisse dans ces cas l√† regarder si le user est propri√©taire de la donn√©e.
Voici √† quoi ressemble le fichier "roleCheck.js":
	const roleCheck = (...authRoles) => {
		return (req, res, next) => {

			if (!req?.roles) {
				return res.sendStatus(403)
			}

			const userRolesChecks = req.roles.map(role => authRoles.includes(role))
			const isAutorized = userRolesChecks.find(val => val === true)

			if (!isAutorized) {
				// S'il y a une autorisation owner on regarde si le user est le propri√©taire de la donn√©e
				if (authRoles.includes("owner")) {
					const pid = parseInt(req.params.id)
					const userId = req.userID
					if (userId != pid) {
						return res.sendStatus(403)
					}
				} else {
					return res.sendStatus(403)
				}
			}

			next()
		}
	}
	module.exports = roleCheck








!!!! Arr√©t√© l√†, 
	Dans le front il faudra sauvegarder le token et les info users(id. pseudo)






#=====================================	
#	Login
#=====================================


https://www.digitalocean.com/community/tutorials/how-to-add-login-authentication-to-react-applications






	

lien utiles:	
	
https://dev.to/novu/building-a-chat-app-with-socketio-and-react-2edj	
https://www.freecodecamp.org/news/build-a-realtime-chat-app-with-react-express-socketio-and-harperdb/
https://github.com/Cocor31/TD_API_DOCKER_SONAR/blob/main/server.js
https://www.digitalocean.com/community/tutorials/how-to-add-login-authentication-to-react-applications






